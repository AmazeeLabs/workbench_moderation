<?php

// $Id: content_moderation.module,v 1.12.2.17 2010/04/18 11:31:29 eugenmayer Exp $

/**
 *
 * @file
 *
 *
 * @TODO i18n is a huge consideration which this module currently does not handle-
 *       this is something to consider for down the road.
 * @TODO for the most part this module is now assuming a more linear editing
 *       workflow. This may need to be rethought down the road.
 *
 * @TODO support revision deletion
 *
 * @TODO on node/11/moderation "view" and node/11/revisions/147/view
 *       should display moderation information
 *
 * @TODO permissions for displaying moderation info on node/X (ie: the live node)
 *       need to be put into place to show moderators that there are other
 *       versions of this content
 *
 * @TODO change all language around "live" to "published to better match drupal
 *       conventions
 *
 *
 *
 */


/* **************************************** */
/* Drupal hooks                             */
/* **************************************** */


/**
 * Implements hook_menu().
 */
function workbench_moderation_menu() {
  $items = array();

  // Display a node's moderation history
  $items["node/%node/moderation"] = array(
    'title' => 'Moderate',
    'description' => 'Show the content moderation history.',
    'type' => MENU_LOCAL_TASK,
    'page callback' => 'workbench_moderation_node_history_view',
    'page arguments' => array(1),
    'theme callback' => '_node_custom_theme',
    'access callback' => '_workbench_moderation_access',
    'access arguments' => array('view history', 1),
    'file' => 'workbench_moderation.node.inc'
  );

  // View the current revision of a node.
  $items["node/%node/current_revision"] = array(
    'page callback' => 'workbench_moderation_node_current_view',
    'page arguments' => array(1),
    'access callback' => '_workbench_moderation_access',
    'access arguments' => array('view revisions', 1),
    'file' => 'workbench_moderation.node.inc'
  );

  // Unpublishing a live revision.
  $items["node/%node/moderation/%/unpublish"] = array(
    'title' => 'Unpublish revision',
    'description' => 'Unpublish the current live revision.',
    'type' => MENU_CALLBACK,
    'page callback' => 'drupal_get_form',
    'page arguments' => array('workbench_moderation_node_unpublish_form', 1),
    'load arguments' => array(3),
    'theme callback' => '_node_custom_theme',
    'access arguments' => array('unpublish live version'),
    'file' => 'workbench_moderation.node.inc'
  );

  // Change the moderation state of a node.
  // @see workbench_moderation_get_moderation_links()
  $items["node/%node/moderation/%/change-state/%"] = array(
    'title' => 'Change Moderation State',
    'page callback' => 'workbench_moderation_moderate',
    'page arguments' => array(1, 5),
    'load arguments' => array(3),
    'access callback' => '_workbench_moderation_moderate_access',
    'access arguments' => array(1, 5),
    'type' => MENU_CALLBACK,
  );

  // Module settings.
  $items["admin/config/workbench/moderation"] = array(
    'title' => 'Workbench Moderation',
    'description' => 'Configure content moderation.',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('workbench_moderation_admin_settings_states'),
    'access arguments' => array('administer workbench moderation'),
    'file' => 'workbench_moderation.admin.inc',
  );
  $items['admin/config/workbench/moderation/general'] = array(
    'title' => 'States',
    'type' => MENU_DEFAULT_LOCAL_TASK,
    'weight' => -1,
  );
  $items['admin/config/workbench/moderation/transitions'] = array(
    'title' => 'Transitions',
    'type' => MENU_LOCAL_TASK,
    'page callback' => 'drupal_get_form',
    'page arguments' => array('workbench_moderation_admin_settings_transitions'),
    'access arguments' => array('administer workbench moderation'),
    'file' => 'workbench_moderation.admin.inc',
  );

  return $items;
}

/**
 * Implements hook_menu_alter().
 */
function workbench_moderation_menu_alter(&$items) {
  // Hijack the node/X/edit page to ensure that the right revision (most current)
  // is displayed.
  $items['node/%node/edit']['page callback'] = 'workbench_moderation_node_edit_page_override';
  $items['node/%node/revisions']['access callback'] = 'workbench_moderation_revision_access';
}

/**
 * Deny access for items we override.
 *
 * If moderation is in use, then the Revisions tab is not used, so we remove access to it.
 * @see _node_revision_access()
 */
function workbench_moderation_revision_access($node, $op = 'view') {
  if (workbench_moderation_node_type_moderated($node->type) === FALSE) {
    return _node_revision_access($node, $op);
  }
  return FALSE;
}

/**
 * Implements hook_permission().
 *
 * Provides permissions for each state to state change
 */
function workbench_moderation_permission() {
  $permissions = array();
  $permissions['administer workbench moderation'] = array(
    'title' => t('Administer Workbench Moderation'),
  );
  $permissions['bypass workbench moderation'] = array(
    'title' => t('Bypass moderation restrictions'),
  );
  $permissions['view moderation history'] = array(
    'title' => t('View moderation history'),
  );
  $permissions['view moderation messages'] = array(
    'title' => t('View the moderation messages on a node')
  );
  $permissions['publish pending version'] = array(
    'title' => t('Publish the current pending version')
  );
  $permissions['unpublish live version'] = array(
    'title' => t('Unpublish the current live version')
  );

  // Per-node-type, per-transition permissions.
  // @see workbench_moderation_state_allowed()
  $node_types = workbench_moderation_moderate_node_types();
  $states = workbench_moderation_states_get();
  foreach ($node_types as $node_type) {
    foreach (array_keys($states) as $from_state) {
      if ($to_states = workbench_moderation_states_next($from_state)) {
        $from_state = check_plain($from_state);
        foreach (array_keys($to_states) as $to_state) {
          $to_state = check_plain($to_state);
          $permissions["moderate $node_type state from $from_state to $to_state"] = array(
            'title' => t('Moderate !node_type state from !from_state to !to_state', array('!node_type' => $node_type, '!from_state' => $from_state, '!to_state' => $to_state)),
          );
        }
      }
    }
  }

  return $permissions;
}

/**
 * Custom access handler for node operations.
 */
function _workbench_moderation_access($op, $node) {
  // The user must be able to view the moderation history.
  $access = user_access("view moderation history");

  // If we do not control this node type, deny access.
  if (workbench_moderation_node_type_moderated($node->type) === FALSE) {
    $access = FALSE;
  }
  // If the user cannot edit this node, deny access.
  if (!node_access('update', $node)) {
    $access = FALSE;
  }
  // If the user cannot view the moderation history, deny access.
  if (!user_access('view moderation history')) {
    $access = FALSE;
  }

  // Allow other modules to change our rule set.
  drupal_alter('workbench_moderation_access', $access, $op, $node);

  return $access;
}

/**
 * Implements hook_help().
 */
function workbench_moderation_help($path, $arg) {
  switch ($path) {
    case 'admin/help#workbench_moderation':
      return '<p>' . t("Enables you to control node display with a moderation
        workflow. You can have a 'Live version' for all visitors and pending
        revisions which need to be approved to become the new 'Live Version.'") . '</p>';
  }
}

/**
 * Implements hook_node_presave().
 * @param <type> $node
 */
function workbench_moderation_node_presave(&$node) {
  global $user;
  // Set the published status when a node is set to live
  // Is this a node that is controlled by content moderation?
  if (isset($node->workbench_moderation_state_new)) {
    // Is the new state live?
    if ($node->workbench_moderation_state_new == workbench_moderation_state_published()) {
      $node->status = 1;
    }
    else {
      $node->status = 0;
    }
  }
  if (workbench_moderation_node_type_moderated($node->type) && empty($node->log)) {
    $node->log = t('Edited by @user.', array('@user' => $user->name));
  }
}


/**
 * Handles the submit of the node form moderation information
 *
 * @param $form
 * @param $form_state
 */
function workbench_moderation_node_insert(&$node) {
  workbench_moderation_node_update($node);
}


/**
 * Implements hook_node_update().
 */
function workbench_moderation_node_update($node) {
  global $user;

  // Is moderation enabled for this content type?
  if (!workbench_moderation_node_type_moderated($node->type)) { return; }

  // Set default state values.
  if (!isset($node->workbench_moderation_state_current)) {
    $node->workbench_moderation_state_current = ($node->status ? workbench_moderation_state_published() : workbench_moderation_state_none());
  };
  if (!isset($node->workbench_moderation_state_new)) {
    $node->workbench_moderation_state_new = variable_get('workbench_moderation_default_state_' . $node->type);
  };

  // Build a history record.
  $node_history = (object) array(
    'from_state' => $node->workbench_moderation_state_current,
    'state' => $node->workbench_moderation_state_new,
    'nid' => $node->nid,
    'vid' => $node->vid,
    'uid' => $user->uid,
    'current' => FALSE,
    'published' => FALSE,
    'stamp' => $_SERVER['REQUEST_TIME'],
  );

  // If this is a new node, or if it is a revision of the current "head", it should become the new
  // current version.
  if (!isset($node->content_moderation) || $node->old_vid == $node->content_moderation['current']->vid) {
    $node_history->current = TRUE;
    $query = db_update('workbench_moderation_node_history')
      ->condition('nid', $node->nid)
      ->fields(array('current' => 0))
      ->execute();
  }

  // If this revision is to be published, it should be the only revision flagged 'published' in
  // {workbench_moderation_node_history}.
  if ($node->workbench_moderation_state_new == workbench_moderation_state_published()) {
    $node_history->published = TRUE;
    $query = db_update('workbench_moderation_node_history')
      ->condition('nid', $node->nid)
      ->fields(array('published' => 0))
      ->execute();
  }

  // Save the node history record.
  drupal_write_record('workbench_moderation_node_history', $node_history);

  // If we're saving a "head" node in a non-published state and there is an existing published
  // version, make the published version live: now we're saving the live revision.
  if (!isset($node->content_moderation)) { $node->content_moderation = array(); }
  if ($node_history->current && !$node_history->published && $node->content_moderation['published'] && !$node->content_moderation['creating_new_revision']) {
    $live_revision = workbench_moderation_node_live_load($node);
    $live_revision->revision = 1;
    $live_revision->status = 1;
    $live_revision->log = $node->log . ' ' . t('Last live revision was: !revision. This is now the current live revision', array('!revision' => $live_revision->vid));
    $live_revision->content_moderation['creating_new_revision'] = TRUE;
    $live_revision->workbench_moderation_state_new = $live_revision->workbench_moderation_state_current;
    node_save($live_revision);
  }

  // Tell the user what is happening to their content if the revision isn't published.
  if (!$node_history->published) {
    drupal_set_message(t('Your content is now awaiting moderation.'), 'status', FALSE);
  }

  return;
}


/**
 * Implements hook_node_load().
 *
 * Load content moderation history and status on a node.
 */
function workbench_moderation_node_load($nodes) {
  foreach ($nodes as $node) {
    // Add the node history
    workbench_moderation_node_data($node);
  }
}


/**
 * Implements hook_node_view().
 */
function workbench_moderation_node_view(&$node, $view_mode = 'full') {
  // Is this a moderated content type?
  if (!workbench_moderation_node_type_moderated($node->type)) {
    return;
  }

  // Is this the live version of this node?
  if ($live_node = workbench_moderation_node_live_load($node)) {
    $has_revision = FALSE;
    $status = 'status';
    if ($live_node->vid != $node->vid) {
      $has_revision = TRUE;
      $status = 'warning';
    }
    $node = $live_node;
    // Alert the user that there are moderated versions
    // Only show this message on node/x
    if (arg(0) == 'node' && is_numeric(arg(1)) && arg(2) == NULL) {
      // Only show the message once and if there are subsequent revisions of
      // this content
      static $live_control = FALSE;
      if (!$live_control && $has_revision && user_access('view content moderation message')) {
        $message = t('This is the live version of this !type.', array('!type' => $node->type));
        $message .= ' ' . t('View the most recent version in moderation !here.', array('!here' => l(t('here'), 'node/' . $node->nid . '/current_revision')));
        drupal_set_message($message, $status, FALSE);
        $live_control = TRUE;
      }
    }
    return;
  }

  // This node is in moderation. If the user has permission to see unpublished
  // nodes, show it and alert the user
  $node = workbench_moderation_node_current_load($node);
  if (arg(0) == 'node' && is_numeric(arg(1)) && arg(2) == NULL) {
    static $revision_control = FALSE;
    if (! $revision_control) {
      drupal_set_message(t('The content of this document has not been approved yet.'), 'warning', FALSE);
      $revision_control = TRUE;
    }
  }


return;

// THIS IS ALL OLDER CODE

  // If we are showing a revision, show the author informations
  if (($live != NULL && $node->vid != $live->vid) && user_access('view content moderation message')) {
    // Get username for the revision rather than the original node.
    $revision_author = user_load_multiple($node->revision_uid);
    drupal_set_message(t('The revision of this node has been created on @date by !author.', array('@date' => format_date($node->revision_timestamp, 'short'), '!author' => theme('username', array('account' => $revision_author)))), 'status', FALSE);
  }
  // If we are showing the live revision of the node and there are any pending version. tell the user about that
  elseif (user_access('view content moderation message')) {
    $pending_revisions = _workbench_moderation_get_latest_revisions($node->nid, 0, NULL);
    $count = count($pending_revisions);

    if ($count == 1) {
      drupal_set_message(t('This document has 1 pending revision', array('@count' => $count)), 'status', FALSE);
    }
    elseif ($count > 1) {
      drupal_set_message(t('This document has @count pending revisions', array('@count' => $count)), 'status', FALSE);
    }
  }
}


/**
 * Implements hook_node_delete().
 */
function workbench_moderation_node_delete($node) {
  // Delete node history when it is deleted
  db_query('DELETE FROM {workbench_moderation_node_history} WHERE nid = :nid', array(':nid' => $node->nid));
}

/**
 * Implements hook_form_alter().
 */
function workbench_moderation_form_node_type_form_alter(&$form, $form_state) {
  // Add JS which handles hiding and showing of these options.
  drupal_add_js(drupal_get_path('module', 'workbench_moderation') . '/js/workbench_moderation.js');
  // What states can this node start out in?
  $form['workflow']['node_options']['#options']['moderation'] = t('Enable moderation of revisions');
  $form['workflow']['node_options']['#description'] .= '<p>' . t('Revisions must be enabled for moderation');
  $form['workflow']['workbench_moderation_default_state'] = array(
    '#title' => t('Default moderation state'),
    '#type' => 'select',
    '#options' => workbench_moderation_states_get(),
    '#default_value' => variable_get('workbench_moderation_default_state_' . $form['#node_type']->type),
    '#description' => t('Set the default workflow state for this content.
      If a user has additional moderation rights they will be able to change it
      on the node')
  );
  $form['#validate'][] = 'workbench_moderation_node_type_form_validate';
}


/**
 * Validate the content type form
 */
function workbench_moderation_node_type_form_validate($from, &$form_state) {
  // Ensure that revisions are enabled if moderation is.
  if ($form_state['values']['node_options']['moderation']) {
    $form_state['values']['node_options']['status'] = 0;
    $form_state['values']['node_options']['revisions'] = 1;
  }
}


/**
 * Implements hook_form_alter().
 *
 * Forcing new reversion and publishing.
 */
function workbench_moderation_form_alter(&$form, $form_state, $form_id) {
  global $user;

  // This must be a node form and a type that has moderation enabled
  if (!(isset($form['#node_edit_form']) && workbench_moderation_node_type_moderated($form['type']['#value']))) {
    return;
  }
  // Set a moderation state even if there is not one defined
  if (isset($form['#node']->content_moderation['current']->state)) {
    $moderation_state = $form['#node']->content_moderation['current']->state;
  }
  else {
    $moderation_state = variable_get('workbench_moderation_default_state_' . $form['type']['#value']);
  }

  // Store the current moderation state
  $form['workbench_moderation_state_current'] = array(
    '#type' => 'value',
    '#value' => $moderation_state
  );
  // We have a use case where a live node is being edited. This will always
  // revert back to the original node status.
  if ($moderation_state == workbench_moderation_state_published()) {
    $moderation_state = workbench_moderation_state_none();
    drupal_set_message(t('%title is currently published to the site. If you edit this page, the new revision must undergo moderation before your changes go live.', array('%title' => $form['#node']->title)), 'warning', FALSE);
  }
  // Get all the states *this* user can access. If states is false, this user
  // can not change the moderation state
  if ($states = workbench_moderation_states_next($moderation_state, $user, $form['type']['#value'])) {
    $current = array($moderation_state => t('Current: !state', array('!state' => $moderation_state)));
    $states = array_merge($current, $states);
    $form['options']['workbench_moderation_state_new'] = array(
      '#title' => t('Moderation state'),
      '#type' => 'select',
      '#options' => $states,
      '#default_value' => $moderation_state,
      '#description' => t('Set the moderation state for this content.'),
      '#access' => $states ? TRUE: FALSE,
    );
  }
  else {
    // Store the current moderation state
    $form['workbench_moderation_state_new'] = array(
      '#type' => 'value',
      '#value' => $moderation_state
    );
  }
  // Move the Revision log under publishing to make things pretty
  $form['options']['log'] = $form['revision_information']['log'];
  $form['options']['log']['#title'] = t('Moderation notes');
  $action = !empty($form['#node']->nid) ? t('Edited') : t('Created');
  $form['options']['log']['#default_value'] = t('!action by @user.', array('!action' => $action, '@user' => $user->name));
  unset($form['revision_information']['log']);

  // Always create new revisions for nodes that are moderated
  $form['revision_information']['revision']['#default_value'] = TRUE;
  // Do not allow users to change the revision status
  $form['revision_information']['#access'] = FALSE;

  // User has no ability to choose if this content is published or not. If the
  // moderation status is live, then it will be published, otherwise not.
  $form['options']['status']['#access'] = FALSE;
}


/* **************************************** */
/* Contrib hooks                             */
/* **************************************** */

/**
 * Needed by the views API
 */
function workbench_moderation_views_api() {
  return array('api' => 2.0);
}


/* **************************************** */
/* Internal functions                       */
/* **************************************** */


/**
 * Overrides the node/X/edit page to ensure the proper revision is shown
 */
function workbench_moderation_node_edit_page_override($node) {
  if (!workbench_moderation_node_type_moderated($node->type)) { return; }

  // Check to see if this is an existing node
  if (isset($node->nid)) {
    // Load the node moderation data
    workbench_moderation_node_data($node);
    // We ONLY edit the current revision
    $node = workbench_moderation_node_current_load($node);
    // Is this revision the same as the live revision?
    if (!isset($node->content_moderation['published']->vid) || $node->vid != $node->content_moderation['published']->vid) {
      // This revision is not live; alert the user
      if (!user_access('bypass workbench moderation')) {
        drupal_set_message(t('You are editing the pending revision (@revision)
          and not the live version of this content. Your changes will be
          moderated before they are reflected.',
          array(
            '@revision' => $node->vid
            )
          ), 'warning', FALSE
        );
      }
    }
  }

  return node_page_edit($node);
}


/**
 * Returns the key which represents the live version.
 * Should be later an interface to change the live state
 */
function workbench_moderation_state_published() {
  return t('Publish');
}

/**
 * Returns the key which represents the neutral non moderated version.
 * Should be later an interface to change the live state
 */
function workbench_moderation_state_none() {
  return t('Draft');
}


/**
 * Determine if this content type is set to be moderated
 *
 * @param $type
 *   String, content type name
 * @return boolean
 */
function workbench_moderation_node_type_moderated($type) {
  // Is this content even in moderatation?
  if (in_array('moderation', variable_get("node_options_$type", array()))) {
    return TRUE;
  }
  return FALSE;
}


/**
 * List of content types that are moderated
 */
function workbench_moderation_moderate_node_types() {
  $types = node_type_get_types();
  $result = array();
  foreach ($types as $type) {
    // Is this content even in moderatation?
    if ( workbench_moderation_node_type_moderated($type->type)) {
      $result[] = $type->type;
    }
  }
  return $result;
}


/**
 * Check whether a user may change the state of a node, based on transition and node type.
 * @see workbench_moderation_permission()
 */
function workbench_moderation_state_allowed($account, $from_state, $to_state, $node_type) {
  return user_access("moderate $node_type state from $from_state to $to_state", $account);
}

/**
 * Adds current and live revision data to a node
 *
 * @param $node
 *   Object, Drupal node object
 */
function workbench_moderation_node_data(&$node) {
  // Make sure that this node type is moderated.
  if (!workbench_moderation_node_type_moderated($node->type) || !isset($node->nid)) { return; }

  $node->content_moderation = array();

  // Fetch the current revision ("head").
  $query = db_select('node_revision', 'r');
  $query->addJoin('LEFT OUTER', 'workbench_moderation_node_history', 'moderation', 'r.vid = moderation.vid');
  $query->condition('moderation.nid', $node->nid)
    ->condition('moderation.current', 1)
    ->fields('moderation')
    ->fields('r', array('title', 'timestamp'));
  $current = $query->execute()->fetchObject();

  // Nodes will lack a workbench_moderation record if they were created before moderation was
  // enabled for their node type. In this case, assume the node is at the current revision.
  if (!$current) {
    $current = (object) array(
      'hid' => NULL,
      'nid' => $node->nid,
      'vid' => $node->vid,
      'from_state' => workbench_moderation_state_none(),
      'state' => ($node->status ? workbench_moderation_state_published() : workbench_moderation_state_none()),
      'uid' => $node->uid,
      'stamp' => $node->changed,
      'published' => $node->status,
      'current' => 1,
    );
  }

  $node->content_moderation['current'] = $current;

  // Fetch the published revision. There may not be a workbench_moderation record for some nodes,
  // but in those cases if the node is published, $current->published will be TRUE.
  if ($current->published) {
    $published = $current;
  }
  else {
    // Fetch the most recent published revision.
    $query = db_select('node_revision', 'r');
    $query->addJoin('LEFT OUTER', 'workbench_moderation_node_history', 'moderation', 'r.vid = moderation.vid');
    $query->condition('moderation.nid', $node->nid)
      ->condition('moderation.published', 1)
      ->fields('moderation')
      ->fields('r', array('title', 'timestamp'));
    $published = $query->execute()->fetchObject();
  }

  if ($published) {
    $node->content_moderation['published'] = $published;
  }

  // Fetch the workbench_moderation record for this node object's revision. If it is either the
  // current or published version of the node, that data will be used.
  if ($node->vid == $current->vid) {
    $my_revision = $current;
  }
  elseif ($published && $node->vid == $published->vid) {
    $my_revision = $published;
  }
  else {
    $query = db_select('node_revision', 'r');
    $query->addJoin('LEFT OUTER', 'workbench_moderation_node_history', 'moderation', 'r.vid = moderation.vid');
    $query->condition('moderation.vid', $node->vid)
      ->fields('moderation')
      ->fields('r', array('title', 'timestamp'));
    $my_revision = $query->execute()->fetchObject();

    // This might happen if you're turning workbench_moderation on and off, but it should be really
    // rare. Workbench_moderation must have recorded a current version, and then the node table must
    // contain a different and unpublished version.
    if (!$my_revision) {
      $my_revision = (object) array(
        'hid' => NULL,
        'nid' => $node->nid,
        'vid' => $node->vid,
        'from_state' => workbench_moderation_state_none(),
        'state' => workbench_moderation_state_none(),
        'uid' => $node->uid,
        'stamp' => $node->changed,
        'published' => 0,
        'current' => 0,
      );
    }
  }

  $node->content_moderation['my_revision'] = $my_revision;
}


/* **************************************** */
/* Utility functions                        */
/* **************************************** */

/**
 * Utility function to load the current version of a node.
 *
 * This is used to load the current moderated version of a node not the live version.
 * This is needed because the live version of a node will have the
 *
 * @param $node
 *   Object, Drupal node
 * @return Object, Drupal node of the current revision or
 */
function workbench_moderation_node_current_load(&$node) {
  // Is there a current revision?
  if (isset($node->content_moderation['current']->vid)) {
    // Ensure that we will return the current version
    if ($node->vid != $node->content_moderation['current']->vid) {
      $node = node_load($node->nid, $node->content_moderation['current']->vid);
    }
  }
  return $node;
}


/**
 * Utility function to load the live version of a node.
 *
 * This is encapsulated so that changes to how the moderation data is stored
 * will not impact the API.
 *
 * @param $node
 *   Object, Drupal node
 * @return Object, Drupal node of the current revision or
 */
function workbench_moderation_node_live_load($node) {
  // Is there a live revision of this node?
  if (isset($node->content_moderation['published']->vid)) {
    // If the live revision is not this version, we need to load that revision
    if ($node->vid != $node->content_moderation['published']->vid) {
      return node_load($node->nid, $node->content_moderation['published']->vid, TRUE);
    }
    // This is the live node, return it
    return $node;
  }
}


/**
 * Utility function to determine if this node is in the live state
 * @param <type> $node
 */
function workbench_moderation_node_is_current($node) {
  if (isset($node->content_moderation['published']->vid)) {
    if ($node->content_moderation['published']->vid == $node->vid) {
      return TRUE;
    }
  }
}

/**
 * Return a list of transitions
 */
function workbench_moderation_transitions_get() {
  static $transitions = FALSE;
  if (! $transitions) {
    $results = db_query("SELECT *
                         FROM {workbench_moderation_transitions} transitions
                           JOIN {workbench_moderation_states} states_from ON transitions.from_name = states_from.name
                           JOIN {workbench_moderation_states} states_to ON transitions.to_name = states_to.name
                         ORDER BY states_from.weight, states_to.weight");
    $transitions = array();
    foreach ($results as $transition) {
      $transinfo = $transition->from_name . '---' . $transition->to_name;
      $transitions[$transinfo] = $transition->from_name . ' -> ' . $transition->to_name;
    }
  }
  return $transitions;
}


/**
 * Return a list of all states in the system
 */
function workbench_moderation_states_get() {
  static $states = FALSE;
  if (!$states) {
    $results = db_query('SELECT * FROM {workbench_moderation_states} ORDER BY weight ASC');
    $states = array();
    foreach ($results as $state) {
      $states[$state->name] = $state->description ? $state->description : $state->name;
    }
  }
  return $states;
}

/**
 * Provides a list of possible next states for this node.
 *
 * @param $current_state
 *   String, current state, optional.
 * @param $account
 *   Object, Drupal user, optional. If this is omitted, all states are returned
 * @param $node_type
 *   String, node type
 * @return array or FALSE
 */
function workbench_moderation_states_next($current_state = FALSE, $account = FALSE, $node_type = FALSE) {
  // Do we have a current state?
  if (! $current_state) {
    $current_state = workbench_moderation_state_none();
  }
  $results = db_query("SELECT to_name AS state
    FROM {workbench_moderation_transitions}
    WHERE from_name = :from_name
      AND (
        ntype = :ntype
        OR ntype = 'all'
      )",
    array(
      ':from_name' => $current_state,
      ':ntype' => $node_type
    )
  );

  $states = array();
  foreach ($results as $state) {
    $states[$state->state] = t($state->state);
  }

  if ($account && $node_type) {
    foreach ($states as $state => $value) {
      if (!workbench_moderation_state_allowed($account, $current_state, $state, $node_type)) {
        unset($states[$state]);
      }
    }
  }
  // Ensure that admins can always take things live.
  $make_live = workbench_moderation_state_published();
  if (user_access('bypass workbench moderation')) {
    $states[$make_live] = $make_live;
  }
  if ($states) {
    return $states;
  }
  return FALSE;
}

/**
 * Menu access callback to check whether a user may make a particular transition on a node.
 */
function _workbench_moderation_moderate_access($node, $state) {
  global $user;

  $my_revision = $node->content_moderation['my_revision'];
  return node_access('update', $node, $user)                                                            // the user can edit the node
          && $my_revision->current                                                                      // this is the current revision (no branching the revision history)
          && ($next_states = workbench_moderation_states_next($my_revision->state, $user, $node->type)) // there are next states the user may transition to
          && isset($next_states[$state]);                                                               // this state is in the available next states
}

/**
 * Menu callback to allow quick moderation of nodes. Access is controlled by the menu router.
 * @see _workbench_moderation_moderate_access()
 * @see workbench_moderation_menu()
 */
function workbench_moderation_moderate($node, $state) {
  global $user;

  $my_revision = $node->content_moderation['my_revision'];

  $node->revision = 1;
  $node->workbench_moderation_state_current = $my_revision->state;
  $node->workbench_moderation_state_new = $state;
  $node->log = t('Moderated by @user', array('@user' => $user->name));

  node_save($node);
  drupal_goto(isset($_GET['destination']) ? $_GET['destination'] : 'node/' . $node->nid . '/moderation');
}

/**
 * Generate a list of links to available moderation actions.
 */
function workbench_moderation_get_moderation_links($node, $url_options = array()) {
  global $user;

  $links = array();
  $my_revision = $node->content_moderation['my_revision'];
  if ($my_revision->vid == $node->content_moderation['current']->vid
      && $next_states = workbench_moderation_states_next($my_revision->state, $user, $node->type)) {
    foreach ($next_states as $state => $label) {
      $links[] = array_merge($url_options, array(
        'title' => $state,
        'href' => "node/{$node->nid}/moderation/{$node->vid}/change-state/{$state}",
      ));
    }
  }

  return $links;
}
